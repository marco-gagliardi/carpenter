import { defineAsyncActions } from './utils'
import {
  getResource,
  loadResources,
  deleteResource,
  updateResource,
  createResource,
  OPERATORS,
  patchResource
} from "../utils/api";

const RESOURCE_ENDPOINT = '{{plural name}}'
const CREATE = defineAsyncActions('CREATE_{{constantCase (plural name)}}');
const FETCH = defineAsyncActions('FETCH_{{constantCase (plural name)}}');
const LOAD = defineAsyncActions('LOAD_{{constantCase (plural name)}}');
const UPDATE = defineAsyncActions('UPDATE_{{constantCase (plural name)}}');
const PATCH = defineAsyncActions('PATCH_{{constantCase (plural name)}}');
const DELETE = defineAsyncActions('DELETE_{{constantCase (plural name)}}');

const DEFAULT_STATE = {
};

export default function reducer (state = DEFAULT_STATE, action) {
  switch (action.type) {
    case CREATE.FULFILLED: {
      return {
        ...state,
        [action.payload.id]: action.payload
      }
    }
    case FETCH.FULFILLED: {
      return {
        ...state,
        [action.meta.id]: action.payload
      }
    }
    case LOAD.FULFILLED: {
      return {
        ...state,
        ...(action.payload.reduce((acc, curr) => {
          return ({...acc, [curr.id]: {...curr}})
        }, {}))
      }
    }
    case UPDATE.FULFILLED: {
      return {
        ...state,
        [action.meta.id]: action.meta.data
      }
    }
    /* Optimistic update approach */
    case PATCH.PENDING: {
      return {
        ...state,
        [action.meta.id]: {...action.meta.data}
      }
    }
    /* optimistic update fallback: revert change */
    case PATCH.REJECTED: {
      return {
        ...state,
        [action.meta.id]: action.meta.snapshot
      }
    }
    case DELETE.FULFILLED: {
      return {
        ...(Object.values(state).reduce((acc, curr) => {
          if (curr.id === action.meta.id) {
            return ({...acc})
          }
          return ({...acc, [curr.id]: {...curr}})
        }, {}))
      }
    }
    default:
      return state
  }
}
export function create{{properCase (plural name)}} (data) {
  return {
    type: CREATE,
    payload: createResource(RESOURCE_ENDPOINT, data)
  }
}

export function fetch{{properCase (plural name)}} (id) {
  return dispatch => {
    const params = {};

    return dispatch({
      type: FETCH,
      payload: getResource(RESOURCE_ENDPOINT, id, params),
      meta: {id}
    })
  }
}

export function load{{properCase (plural name)}} ({limit, lastId, ...params}) {
  /* params should be something like {lastId, orderBy, orderDir, limit} */
  if (limit) params[OPERATORS.limit] = limit
  if (lastId) params[OPERATORS.lastId] = lastId
  return (dispatch) => {
    return dispatch({
      type: LOAD,
      payload: loadResources(RESOURCE_ENDPOINT, params),
    }).then(payload => payload.value)
  }
}

export function update{{properCase (plural name)}} (id, data) {
  return {
    type: UPDATE,
    payload: updateResource(RESOURCE_ENDPOINT, id, data),
    meta: {id, data}
  }
}

export function patch{{properCase (plural name)}} (id, data) {
  return (dispatch, getState) => {
    return dispatch({
      type: UPDATE,
      payload: patchResource(RESOURCE_ENDPOINT, id, data),
      meta: {id, data, snapshot: getState()['{{plural name}}'][id]}
    })
  }
}

export function delete{{properCase (plural name)}} (id) {
  return dispatch => {
    return dispatch({
      type: DELETE,
      payload: deleteResource(RESOURCE_ENDPOINT, id),
      meta: {id}
    })
  }
}